<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>scrhide</title>
	<script src="https://cdn.tailwindcss.com"></script>
</head>




<style>
@media (max-height: 700px){ 
	.search-wrapper {
		padding: 0 0 30px;
	}
}
.search-wrapper {
	padding: 34px 0 38px;

}
*, ::before, ::after {
	box-sizing: inherit;
}
.outer-wrapper {
    color: var(--newtab-text-primary-color);
}
élément {
    --newtab-search-icon: url(moz-extension://474b919b-d250-4c66-afd0-0ddca1d19971/favicon.ico);
}
body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Ubuntu", "Helvetica Neue", sans-serif;
    font-size: 16px;
}
/* custom */
main{
	width: 90%;
	position: relative;
	height: 100%;
	display: block;
	background-color: #2a5ea669;
	margin: auto;
}
main *{
	text-align: center;
}
body{
	background-color: #0000834e;
}
body section{
	background-color: rgba(255, 255, 255, 0.644);
}

</style>
<body>
	<!-- centralizer -->
	<section class="max-w-md mx-auto bg-white-250 rounded-xl shadow-md overflow-hidden md:max-w-7xl padding-ms p-10">
		<header class="w-max max-8 ml-auto mr-auto p-8">
			<h1>interactivité spatiale avec js</h1>
		</header>
		<main>
			<div id="canvasFlow" class="outline border-4 border-inherit bg-transparent outline-blue-300 rounded">
				<canvas id="canvas1" class="mx-auto rounded-xl shadow-md overflow-hidden md:max-w-2xl size-full"></canvas>		
			</div>

		</main>
	</section>

</body>
<!-- mime warnings -->
<script>
	const canvas = document.getElementById("canvas1")
	const ctx = canvas.getContext("2d")
	// css rules are broken for rendering canvas shapes so we use client infos for custom size
	function freeScale(e){
		const parent = e.parentElement // this represent the content outside function not the function object itself
		e.style.height = parent.clientHeight*0.95
		e.style.width = parent.clientWidth
	}

	document.getElementById("canvas1").addEventListener("onresize", function(){
		freeScale(this)
	})


	function randi(min, max) {
 		const floatRandom = Math.random()
		const difference = max - min
		// random between 0 and the difference
		const res = Math.round(difference * floatRandom) + min
		return res
	}

	class User{
		#x
		#y
		#he=0
		#ctx
		#repr
		constructor(x,y,he,ctx){
			this.#x = x
			this.#y = y
			this.#he = he
			this.#ctx = ctx
			this.#repr = {
				color: "skyblue",
				x: ()=>this.#x,
				y: ()=>this.#y,
				w: 15,
				h: 10,
				he: ()=>(this.#he * Math.PI) / 180
			}
		}
	
		move(canvasW, canvasH){
			const tmpx = randi(-10,10)
			const tmpy = randi(-10,10)
			if(this.#x+tmpx > 0 && this.#x+tmpx < this.#repr.w)
				this.#x+=tmpx
			if(this.#y+tmpy > 0 && this.#y+tmpy < this.#repr.h)
				this.#y+=tmpy
		}

		render(w,h){
			this.#clear(w, h)
			this.#ctx.fillStyle = this.#repr.color
			this.#ctx.fillRect(
				this.#repr.x(),
				this.#repr.y(),
				this.#repr.w,
				this.#repr.h
			)
  			this.#ctx.rotate(this.#repr.he())
		}
		#clear(w,h){
			this.#ctx.rotate(-this.#repr.he())
			this.#ctx.clearRect(0,0,w,h)
		}

	}
	class Run{
		#items = []
		#speed = 500
		#surface
		constructor(canvas){
			this.#surface = canvas
		}
		addItem(newItem){
			this.#items.push(newItem)
		}
		addGroupItems(group){
			this.#items.push(...group)
		}	
		renderer(){
			// private variables not allowed here
			const localItems=this.#items
			const localSpeed=this.#speed
			const localSurface=this.#surface
			setInterval(function render() {
				// must implement render on each elems
				for (let i=0;i<localItems.length;i++){
					localItems[i].render(localSurface.width,localSurface.height)
					localItems[i].move(localSurface.clientWidth,localSurface.clientHeight)
				}
			}, localSpeed);
		}


	}

	// main prog
	let me = new User(
		canvas.clientWidth,
		canvas.clientHeight,
		15,9,ctx)
	let gm = new Run(canvas)
	gm.addItem(me)
	gm.renderer()
	
</script>
</html> 

<!-- end page -->